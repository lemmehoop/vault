Used for applications decoupling (развязать сильную зависимость между приложениями)
![[Pasted image 20241224105339.png|500]]
fanout - во все очереди
direct - routing key сверяется с binding key
topic - совпадение части binding key и routing key
header - по заголовкам
default - routing key сверяется с названием очереди
***
**Durable queue** - очередь сохранится при перезагрузке брокера
***
**RabbitMQ** - распределенный и горизонтально масштабируемый брокер сообщений.
### Подключение
Установка подключения требует большого количества пакетов (7 без и 12 с TLS), поэтому открывать и закрывать соединения накладно. Для этого AMQP вводит понятие *channels*, которые являются соединениями внутри "внутри" соединений, где и идет работа.
И соединения, и каналы рассчитаны на то, чтобы "жить" долго (по крайней мере соединения точно).

Если для каждой публикации открывать соединение и канал заново, то будут созданы и использованы 19 пакетов вместо 1, из-за чего сильно пострадает производительность.

Стоит придерживаться принципа *один процесс - одно соединение*. Каждый же поток будет использовать свой собственный канал.

Механизм *heartbeats* нужен для проверки состояние подключений. Клиент и брокер выбирают таймаут и отсылают сигналы с периодичность в половину таймаута. Если два раза не получен отчет - подключение считается нерабочим.

Многие библиотеки инкапсулируют логику переподключения, но это очень важно. 
### Маршрутизация
Топология - совокупность обменников (*exchanges*), очередей (*queues*) и связей (*bindings*) между ними.
Объявление топологии:
- если элементов нет - они создаются
- элементы есть и их настройки совпадают - ничего не происходит
- элементы есть, но настройки отличаются - возникает ошибка

При перезапуске брокеры выживут только те элементы, которые изначально были объявлены как *durable*.
Объявлять топологию лучше всего в коде приложения, чтобы избежать ошибок и всегда использовать правильную топологию.

В качестве защиты от *потерь сообщений* лучше всего использовать *alternate-exchange* в настройках основного обменника, чтобы складировать туда сообщения, для которых не нашлось маршрутов шли туда. Ну и конечно - там должна быть очередь, чтобы собирать туда сообщения.

Для того, чтобы кролик не выбрасывал мертвые сообщения, можно указать у него *dead-letter-exchange*.
### Публикация
*delivery-mode=2* в сообщений сделает его способным пережить перезагрузку.
*mandatory=true* нужно, чтобы сообщение вернулось, если для него нашелся маршрут. Иначе кролик его просто выбросит.
Для каждого процесса, который кладет и забирает сообщений лучше сделать два соединения, чтобы один поток не переполнял сообщения идущие обратно.
### Потребление
*no-ack=false* нужно для того, чтобы кролик не удалял сообщения сразу же после того, как поместил их буффер на отправку клиенту. Но тут клиенту очень важно правильно отправлять *ack* сообщения брокеру.
*prefetch-count* - настройка на потребителе, которая ограничивает количество сообщений, которое может держать у себя не обрабатывая, чтобы брокер не слал сообщения бесконечно. Также это помогает в урегулировании нагрузки между узлами.
### Мониторинг
- Объем данных в очереди (если задан максимум, то новые сообщения могут просто удаляться);
- Количество сообщений в очереди может свидетельствовать о проблемах на потребителе;
- Количество потребителей очереди - чтобы отследить, что потребитель вышел из строя до того, как начались проблемы с количеством нагрузки;
- Наличие немаршрутизируемых сообщениях;
- Наличие сообщений в DLX, чтобы увидеть проблемы в обработке сообщений.

https://habr.com/ru/companies/tochka/articles/799949/

***
```python
broker = RabbitBroker()
app = FastStream(broker)
exch = RabbitExchange("exchange", auto_delete=True)
queue = RabbitQueue("test-q-1", auto_delete=True)

@broker.subscriber(queue, exch)
async def base_handler1(logger: Logger):
	logger.info("base_handler1")
```