### Магические методы
```python
```
Начинаются с двух подчеркиваний и нужны для работы параметрического полиморфизма (чтобы встроенные функции и операторы питона работали по разному с разными классами объектов).
- add - сложения объекта с другим (radd - если наш объект справа и у объекта слева не реализован add)
- то же самое для все остальных инфиксных операторов
***
Если у объекта нет repr / str - лучше реализовать repr, потому что он будет вызываться, если str отсутствует. А в целом str нужен для нормального визуального представления, тогда как repr для воспроизведения этого объекта.
***
Булево представления объекта реализуется с помощью метода __bool__. По умолчанию любой объект будет выдавать True.
### Коллекции
![[Pasted image 20241231122355.png|500]]
### Последовательности
**Контейнерные** - могут хранить в себе элементы разных типов (list, tuple, collections.deque), то есть хранят именно ссылки на другие объекты.
**Плоские** - хранят элементы только одного типа (str, bytes, array.array). Тут данные хранятся не ссылками, а по порядку объектами в памяти.
![[Pasted image 20241231123200.png|400]]
***
Кортежи - не просто неизменяемы списки: они выступает и в качестве записей с неименованными полями. Они потребляют меньше памяти, чем списки, поэтому производительнее (списку нужно выделять больше памяти для амортизации дальнейших вставок + кортеж сразу хранит ссылки в своей структуре, тогда как список хранит ссылку на список ссылок, чтобы по необходимости можно было перезаписать все ссылки в другое место в памяти).
Не изменяются в нем только ссылки на объекты, а сами же объекты по этим ссылками могут изменяться, что вводит ограничение на хэшируемость кортежей.
### match case
По сути является сопоставлением с последовательностями-образцами.
![[Pasted image 20241231124213.png|400]]
Инструмент *деструктуризации*.
### Сортировка
`.sort()` сортируем список на месте, тогда как `sorted()` всегда возвращает список, хотя и принимает на вход даже итерируемые объекты.
Сортировка в питоне устойчива, потому что сохраняет относительный порядок элементов признанных равными (например, если сортировка по длине слова и они одинаковой длины, то их порядок из изначального списка сохранится).
### Массивы
`array.array` занимает в памяти столько же места, сколько массив языка C.
Массив float не хранит полноценные объекты, а только упакованные байты, которыми представляются их машинные значения.
При этом массив поддерживает почти весь функционал списков (`pop`, `insert`, `extend`, но нет сортировки и вставки перед заданным индексом).
### deque
```python
from collections import deque
```
`append` -> `appendleft`
`extend` -> `extendleft`
Операции `append` и `popleft` атомарны, поэтому можно использовать *deque* в многопоточных приложениях в качестве **FIFO** очереди.
### Словари и множества
Python - по сути своей словари, обернутые большим количеством синтаксического сахара.
Атрибуты классов, экземпляров, пространства имен модулей, именованные аргументы - лишь небольшая часть того, где используются словари.
Из-за чего они высокооптимизированы.
**Объединение отображений**
```python
{"a": 1, **{"b": 2, "a": 1}}  # {"b": 2, "a": 1}
{"a": 1} | {"b": 2}  # создает новое отображение, |= оставит тот же
```
**Match case**
```python
def get_creators(record: dict) -> list:
	match record:
		case {'type': 'book', 'api': 2, 'authors': [*names]}:
			return names
		case {'type': 'book', 'api': 1, 'author': name}:
			return [name]
		case _:
			raise ValueError(f'Invalid record: {record! r}')
```
### Хэшируемость
Объект называется хешируемым, если имеет хеш-код, который не изменяется на протяжении всего времени его жизни (у него должен быть метод __hash__()), и допускает сравнение с другими объектами (у него должен быть метод __eq__()). Если в результате сравнения хешируемых объектов оказывается, что они равны, то и их хеш-коды должны быть равны.