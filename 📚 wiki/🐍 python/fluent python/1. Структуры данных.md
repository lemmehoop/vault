### Модель данных
```python
import collections

# namedtuple используется для конструирования классов без методов
Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:  
	ranks = [str(n) for n in range(2, 11)] + list('JQKA')
	suits = 'spades diamonds clubs hearts'.split()

	def __init__(self):  # инициализация объекта класса
		self._cards = [Card(r, s) for s in self.suits for r in self.ranks]

	def __len__(self):   # получения "длины" объекта
		return len(self._cards)

	def __getitem__(self, position):  # получения элемента через "[]"
		return self._cards[position]
```
***
Если у класса нет метода `__contains__`, то при вызове `in` будет последовательный просмотр.
***
`len()` - не метод, а что-то среднее, потому что для встроенных типов, реализованных на C, длина получается из атрибута `PyVarObject.ob_size`, без фактического вызова. Тогда как для кастомных классов - вызов `__len__`.
***
Чаще всего **специальные методы** вызываются интерпретатором или неявно (с помощью встроенных функций `iter`, `len`, ...).
***
Для строкового представления числа лучше всего реализовать метод `__repr__`, так как при отсутствии `__str__` будет вызван он.
`__repr__` в свою очередь должен максимально приближенно представлять создание объекта, тогда как `__str__` - строку, пригодную для показа пользователю.
***
`__bool__` - булево представление объекта, которое используется при его подстановке в выражения.
По умолчанию пытается вызвать `__bool__`, потом `__len__`, а иначе всегда `True`.
***
**ABC** - abstract base class.
API коллекций представлено ниже:
- `Iterable` - для `for`
- `Sized` - для `len()`
- `Container` - для `in`
- `Collection` - **list / str**
- `Mapping` - **dict / collections.defaultdict**
- `Set` - **set / frozenset**
	- тут реализованы **инфиксные** операторы
![[Pasted image 20250727182108.png|400]]
***
В питоне есть множество специальных методов типа `__*__`, которые нужны для изменения поведения базового функционала.
`__<name>__`, `__r<name>__` - инверсный оператор (когда у первого операнда не реализовано поведение при нужных типах), `__i<name>__` - составное присваивание (`+= / -= / ...`).
***
Благодаря специальный методам в питоне можно сделать так, чтобы пользовательские классы имели все возможности встроенных классов, тогда как например в **Golang** - итерируемые объекты ограничены 5 *магическими* типами.
### Последовательности
Все последовательности в питоне имеют примерно одинаковый набор операций, благодаря хорошим интерфейсам.
***
**Контейнерные последовательности** - `list` / `tuple` / `collections.deque`, хранят в памяти ссылки на объекты любого типа.
**Плоские последовательности** - `str` / `bytes` / `array.array`, хранят сами значения в памяти, занятой последовательностью, а не как отдельные объекты.
- поэтому компактнее и занимают меньше места, но могут содержать только значения примитивных типов (байты, числа, строки)
- занимает меньше места, потому что каждый объект в питоне имеет заголовок с метаданными (счетчик ссылок, указатель на тип, значение): в кортеже таких заголовков и самих объектов будет много, а у массива всего один
![[Pasted image 20250727183519.png|400]]
***
**Изменяемые последовательности** - `list` / `bytearray` / `array.array` / `collections.deque`
**Неизменяемые последовательности** - `tuple` / `str` / `bytes`
![[Pasted image 20250727203830.png|400]]
Встроенные тип последовательностей не наследуются от этих классов, а являются лишь *виртуальным подклассами*:
```python
from collections import abc
issubclass(tuple, abc.Sequence)        # True
issubclass(list, abc.MutableSequence)  # True
```
***
**Списковые включения** - синтаксический сахар для создания списков по итерируемым объектам. Можно использовать сразу несколько циклов `for` внутри одного включения, при этом порядок будет такой же, как и при вложенном написании этих циклов друг за другом (то есть последний пройдет раньше всех).
Списковое включение не медленнее функций высшего порядка `filter + map`.
```python
codes = [ord(sym) for sym in "ABCD" if ord(sym) > 70] # списковое включение
codes_gen = (ord(symbol) for symbol in "ABCD")        # генераторное выражение

with_filter = list(filter(lambda c: c > 127, map(ord, symbols)))
```
**Генераторное выражение** - экономит память, так как отдает элементы по одному, вместо того, чтобы строить список сразу.
```python
import array

# можно убирать лишние скобки, если генератор - единственный аргумент
tuple(ord(symbol) for symbol in symbols)
array.array('I', (ord(symbol) for symbol in symbols))  # тут скобки обязательно
```
***
**Кортежи** - в первую очередь последовательность
- как запись: каждый элемент содержит данные одного поля, а его позиция определяет его семантику
- неизменяемый список
	- его длина не изменяется
	- потребляет меньше памяти
		- байт-код сразу кладет данные в константу, тогда как каждый элемент списка сначала идет в стек как отдельная константа, и только потом в сам список
		- выделяется ровное количество памяти, без амортизации
		- кортеж хранит массив ссылок в себе, тогда как список хранит ссылку на массив ссылок, чтобы при перезаписи поменять его
- ссылки на объекты неизменны, но сами объекты по ссылкам могут быть изменены
	- то есть он хэшируем, только если все внутри тоже
***
**Распаковка** - удобный способ получения объектов из другого итерируемого объекта, без использования индексов и циклов.
```python
# звездочку можно ставить в любом месте
a, b, *rest = range(5)         # (0, 1, [2, 3, 4])

# распаковка вложенного объекта
a, b, (c, d) = [1, 2, (3, 4)]  # (1, 2, 3, 4)
```
***
**Сопоставление с последовательностями-образцами** - удобный инструмент деструктуризации и сравнения.
`str`, `bytes`, `bytearray` - не деструктуризируются, чтобы избежать ошибок. Если нужно, можно создать из них кортеж: `tuple("asd")`.
Это пример *декларативного* программирования: мы обозначаем, "что" хотим сопоставить, а не "как".
```python
# в этом примере идет деструктуризация и сравнение первого элемента (имени),
# пропуск двух элементов, и сравнение координат с типами;
# в контекст сопоставления это не конструктор, а сравнение типа
match record:
	case ["John", _, _, (float(lat), float(lon))] if lon <= 0:
		print(f"{lat}:{lon}")
```
***
Для среза `seq[i:j]` вызывается `seq.__getitem__(slice(i, j))`.
```python
l = [1, 2]
l *= 2  # [1, 2, 1, 2]
t = (1, 2)
t *= 2  # (1, 2, 1, 2), но ссылка станет другой, потому что нет __imul__
```
***
В python принято, что функции, изменяющие сам объект, возвращают `None`: например, `list.sort()` или `random.shuffle`.
Для сортировки python использует `Timsort` (Tim - автор сортировки и дзена питона):
- сортировка вставками при сильном разделении на маленькие участки;
- сортировка слиянием (merge sort) - при больших объемах.
Функция далее позволяет держать последовательность отсортированной при вставках, однако расходует **O(log(n))** на поиск места и **O(n)** на вставку.
```python
import bisect

a = [1, 3]
bisect.insort(2)  # [1, 2, 3]
```
***
`array.array` намного выгоднее при хранении примитивных типов, потому что хранит запакованные байты, а не сами объекты, причем имеет функцию по загрузке и выгрузке себя в двоичный файл, что в разы быстрее, чем записывать и читать из текстового файла.
```python
from array import array

octets = array('B', range(6))
m1 = memoryview(octets)    # m.tolist() => [0, 1, 2, 3, 4, 5]
m2 = m1.cast('B', [2, 3])  # m2.tolist() => [[0, 1, 2], [3, 4, 5]]
```
***
`deque` - отличная потокобезопасная альтернатива `list`, если нужно постоянно вставлять и читать значения из двух концов (*double ended queue*).
`append` и `popleft` атомарны.
Большой минус - операции удаления из середины идет медленно.
```python
from collections import deque

d = deque(range(5), maxlen=5)  # maxlen достигнут => -1 элемент с другого конца
d.extendleft([10, 20, 30, 40])   # deque([40, 30, 20, 10, 0], maxlen=5)
```
### Словари и множества
*Словари* - краеугольный камень питона. Пространства имен, атрибуты объектов, именованные аргументы функций и многое другое хранится в них.
Поэтому они очень хорошо оптимизированы и предлагают широкий ассортимент функций для `dict`, `set`, `frozenset`.
`types.MappingProxyType` позволяет сделать `read-only` словарь.
***
Строки в **хэш-таблице** - **бакеты**.
☢️ Оптимизации:
- использование **пробинга** при совпадении хэшей;
- после определенного количества коллизий питон выбирает псевдорандомный индекс и идет вставлять туда, потому что иначе увеличивается количество проб индексов в цикле;
- если бакеты заполнены на `2/3`, то размер удваивается
![[Pasted image 20250730161647.png|600]]
***
В **словарях** схема немного другая (но такая же при коллизиях):
- хранить все значения в бакете не оптимально, потому что далеко не все они заполнены, при этом место все равно выделено --> бакеты хранятся отдельно и содержат только индекс строки из массива
	- [u] место в массиве выделяет оптимальнее, только при реальном добавлении элементов
	- [u] сохраняется порядок вставки объектов в словарь
		- но не сверяет порядок ключей при сравнении словарей;
		- хуже справляется, когда идет переупорядочивание;
![[Pasted image 20250730211033.png]]
***
```python
# словарное включение
squares = {i: i ** 2 for i in range(3) if i % 2 == 0}  # {0: 0, 2: 4}

# распаковака именованных аргументов в функциях
func(**{'a': 1}, b=2, **{'c': 3})

# объединения словарей, при этом при совпадении ключей - возьмем последний
{'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}}

# объединение через __or__, __ior__
d1 = {"a": 1}
d2 = {"b": 2}
d1 | d2   # {"a": 1, "b": 2} => новый словарь
d1 |= d2  # d1 = {"a": 1, "b": 2}
```
***
**Сопоставление с образцом**
- порядок ключей в образце не имеет значения;
- могут быть ключи, которых в образце нет, но все равно подойдет;
```python
def get_creators(record: dict) -> list:
	match record:
		case {'type': 'book', 'api': 2, 'authors': [*names]}:
			return names
		case {'type': 'book', 'api': 1, 'author': name}:
			return [name]
		case {'type': 'book', **other}:
			raise ValueError(f'Incorrect book: {other}')
		case _:
			raise ValueError(f'Invalid record: {record! r}')
```
***
**Хэшируемый объект** - имеет хеш-код, который не изменяется на протяжении всего времени его жизни (у него должен быть метод `__hash__()`), и допускает сравнение с другими объектами (у него должен быть метод `__eq__()`). Если в результате сравнения хешируемых объектов оказывается, что они равны, то и их хеш-коды должны быть равны.
***
Стандартный базовые классы для отображений:
```python
from collections.abc import Mapping, MutableMapping
```
![[Pasted image 20250730213250.png|500]]
***
Метод `__missing__` нужно использовать, если хочется поменять поведение при отсутствии ключа в словаре.
```python
from collections import defaultdict, ChainMap, Counter

index = defaultdict(list)
index["key"].append("some value")

index = {}
index.setdefault("key", []).append("some value")

# объединение словарей, при этом хранение только ссылок
# добавление идет только в первый словарь
pylookupdict = ChainMap(locals(), globals(), vars(builtins))

ct = Counter('abracadabra')  # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
ct["F"]  # => 0
```
***
Если нужно создать **свой** словарь, то лучше использовать `collections.UserDict`:
- хранит сами значение в словаре в атрибуте `data`;
- т.е. использует композицию;
```python
class StrKeyDict(collections.UserDict):
	def __missing__(self, key):
		if isinstance(key, str):
			raise KeyError(key) return self[str(key)]

	def __setitem__(self, key, item):
		self.data[str(key)] = item
```
***
Ключи и значения словаря являются отдельными типами данных, которые не дублируют информацию, а являются неизменяемыми проекциями реальных данных.
Эти классы нельзя создать и использоваться, они доступны только из словаря и нужны для операций над внутренними множествами словарей (`.keys` и `.items` очень похожи на `frozenset`).
```python
d = dict()
d.keys()   # 'dict_keys'
d.values() # 'dict_values'
d.items()  # 'dict_items'
```
### Множества
Набор уникальных объектов, и главное использование - устранение дубликатов.
Элементы должны быть хешируемыми, тогда как сам `set` - не хешируемый.
`frozenset` - хешируемый.
```python
s = set()      # создание пустого множества
s = {1, 2, 3}  # создание непустого множества, выглядит в точности как математическая нотация
s = {chr(i) for i in range(32, 65)}  # множественное включение
```
***
- нельзя верить порядку вставки - он не сохраняется
- после заполнения `2/3` множество переносится, и порядок теряется
***
![[Pasted image 20250830114707.png]]
```python
from collections.abc import Collectio, Set, MutableSet
```
***
```python
&       # пересечение
|       # объединение
-       # разность
^       # симметрическая разность
in      # проверка на вхождение
<=      # проверка на подмножество
>=      # проверка на надмножество
add     # добавить
clear   # стереть все
copy    # поверхностная копия
discard # удалить элемент, если есть
pop     # удалить и вернуть элемент
remove  # удалять элемент, возбудив исключение при отсутствии
```
### Unicode-текст и байты
**Строка** - последовательность символов.
**Символ** - символ Unicode. Стандарт Unicode разделяет идентификатор символа и конкретное байтовое представление.
*Идентификатор* - кодовая позиция, число от 0 до 1_114_111, которое в стандарте записывается в шестнадцатеричном виде (например, `A ~ U+0041`).
Какими именно байтами представляется символ зависит от используемой *кодировки*.
**Кодировка** - алгоритм преобразования кодовых позиций в последовательность байтов.
`A -> \x41 (utf-8), -> \x41\x00 (utf-16)`
***
В `str` срез из одного элемента будет равен элементу, полученному по индексу: `s[0] == s[:1]`. В любых других последовательность будет возвращена последовательность и нет места такому равенству.
У `bytearray` нет литерального синтаксиса, только конструктор.
Байтовые типы данных поддерживают практически все методы строк, кроме форматирования данных (`format, format_map`) и зависящих от Unicode: `casefold / isdecimal / encode` и другие. 
***
```python
cafe = bytes("café", encoding="utf-8")  # b'caf\xc3\xa9'
cafe[0]                                 # 99 -> ord("c")
cafe[:1]                                # b'c'

cafe_array = bytearray(cafe)            # bytearray(b'caf\xc3\xa9')
cafe_arr[-1:]                           # bytearray(b'\xa9')
```
***
**Codec (кодек)** - кодеровщик / декодеровщик.
У него есть имя и его можно передать в `open / encode / decode` и т.д.
UTF-8 - самая употребительная 8-битовая кодировка в мире.
В большинстве кодеков, не входящих в `UTF-` семейство есть лишь подмножество символов Unicode, из-за возможны ошибки.
`str.isascii` может проверить, все символы в строке из стандарта ASCII.
Для упрощения работы и предотвращения ошибок лучше везде и всегда четко описывать, какая кодировка используется, потому что по дефолту это значение в разных ОС может быть разным.
***
Как узнать какая кодировка используется в последовательности байтов - по сути никак.
Можно попробовать раскодировать, обратить внимание на разные символы, специфичные для кодировок, но лучше всего - если кодировка заранее известна.
***
Обработка текстовых файлов должна происходить с помощью *сэндвича Unicode*: приведение `bytes` в `str` должно произойти как можно раньше и лучше в коде работать именно со строковым типами данных. И точно так же как можно позже переводить эти типы обратно.
- [!] Лучше не открывать файл в двоичном режиме, если работаете с текстовыми файлами. Двоичный режим стоит использовать только для открытия двоичных файлов, например, растровых изображений.
***
В Linux / MacOS по умолчанию почти везде используется UTF-8, однако в Windows это не так: для файлов скорее всего `cp1252`, в консоли UTF-8 и другие приколы, которые могут зависеть еще и от локали конкретного компьютера.
***
```python
import locale
locale.getpreferredencoding()  # кодировка используемая для файлов по умолчанию

import sys
sys.getdefaultencoding()        # используется интерпретатором для неявных преобразований двоичных данных в строку и обратно, поменять в коде нельзя
sys.getfilesystemencoding()     # применяется для кодирования и декодирования имен файлов, но не их содержимого; используется в open(), например

```
***
Не всегда сравнение двух строк работает корректно:
```python
s1 = 'café'
s2 = 'cafe\N{COMBINING ACUTE ACCENT}'  # s1 != s2, хотя в выводе то же самое

from unicodedata import normalize
normalize("NFC", s1) == normalize("NFC", s2)  # True
```
***
В реальной жизни для сравнения скорее всего достаточно просто привезти две строки к одному регистру. Для этих целей лучше всего использовать `str.casefold`, которая работает почти как `str.lower`, но проводит еще некоторые махинации, которые приводят символы к более каноническому с точки зрения Unicode виду.
***
Проблема есть и с сортировкой, потому что по умолчанию обычная сортировка не учитывает правильный порядок символов в целевом алфавите.
```python
import locale
fruits = ['caju', 'atemoia', 'cajá', 'açaí', 'acerola']
sorted_fruits = sorted(fruits, key=locale.strxfrm)  # правильная сортировка, но для этого на компьютере должна быть установлена правильная локаль
```
***
```python
# получение имени символа по имени
from unicodedata import name
name("A")  # LATIN CAPITAL LETTER A
```
***
Начиная с версии Python 3.3 интерпретатор, создавая объект str, проверяет, из каких символов он состоит, и выбирает наиболее экономичное размещение в памяти данного объекта. Если имеются только символы из диапазона `latin1`, то каждая кодовая позиция str будет представлена всего одним байтом. В противном случае для представления кодовой позиции может понадобиться 2 или 4 байта – все зависит от str. 
Гибкое представление строки похоже на представление типа int в Python 3: если целое число умещается в машинном слове, то оно и хранится как одно машинное слово. В противном случае интерпретатор переходит на представление переменной длины, как для типа long в Python 2.
### Построители классов данных
`typing.TypedDict` не является строителем классов данных в привычном виде, так как является лишь синтаксисом написания аннотаций типов параметров функций и переменных.
***
Почему класс с обычным конструктором не лучшая идея:
- в `__init__` для установки значения одной переменной ее имя придется упомянуть три раза
- в нем не будет нормально работающего метода `__eq__` для верного сравнения
- `__repr__` унаследованный от `object` не сильно полезен
`collections.namedtuple`, `typing.NamepTuple` и `@dataclass` решают эти проблемы.
Первый два - подклассы `tuple`, тогда как датаклассы наследуются от `object` и лишь получают дополнительные свойства от декоратора.
***
```python
from collections import namedtuple
Coordinate = namedtuple("Coordinate", "lat lon")  # второй параметр - любой итерируремый объект с названиями полей

from typing import NamedTuple
Coordinate = NamedTuple("Coordinate", [("lat", float), ("lon", float)])
# or
Coordinate = NamedTuple('Coordinate', lat=float, lon=float)
```
***
В PEP 526 было предложено аннотировать типы в конструкции `class`.
```python
from typing import NamedTuple

# хотя тут и используется синтаксис наследования, это не наследование, а метапрограммирование, поэтому Coordinate все равно останется потомком именно tuple, а не NamedTuple
class Coordinate(NamedTuple):
	lat: float
	lon: float

	def __str__(self):
		ns = 'N' if self.lat >= 0 else 'S'
		we = 'E' if self.lon >= 0 else 'W'
		return f'{abs(self.lat):.1f}°{ns}, {abs(self.lon):.1f}°{we}'
		
# or

from dataclasses import dataclass

# не опирается ни на наследование, ни на метклассы, поэтому можно оставить / реализовать свою логику работы с наследованием
@dataclass(frozen=True)
class Coordinate:
	lat: float
	lon: float
	
	def __str__(self):
		ns = 'N' if self.lat >= 0 else 'S'
		we = 'E' if self.lon >= 0 else 'W'
		return f'{abs(self.lat):.1f}°{ns}, {abs(self.lon):.1f}°{we}'
```
***
Сходства и различия:
- `namedtuple / NamedTuple` неизменяемые, но датакласс можно сделать таким при `frozen=True`
- `NamedTuple / @dataclass` поддерживают синтаксис классов
- для конструирования словаря `namedtuple / NamedTuple._asdict` / `dataclasses.asdict(instance)`
- для получения полей и значений по умолчанию `tuple._fields / tuple._field_defaults` / `dataclasses.fields(instance)` - второе возвращает кортеж объектов `Field` в именем и дефолтным значением
- `NamedTuple / @dataclass` имеют `__annotations__` с отображением имен полей на их типы (получать их лучше через `typing.get_type_hints`)
- `tuple._replace(**kwargs)` возвращает новый экземпляр с измененными полями
- создавать именованные кортежи находу можно, а для датаклассов `dataclasses.make_dataclass`
- методы сравнение кортежи наследуют от обычного кортежа
***
```python
from dataclasses import dataclass

@dataclass(
	init=True,  # создает метод __init__
	repr=True,  # создает __repr__
	eq=True,    # создает __eq__
	order=False, # __lt__, __gt__, исключение, если True и eq=False
	unsafe_hash=False, # создается метод __hash__, зависит от frozen
	frozen=False, # делает неизменяемым, но не до конца, будет ошибка кастомная
	slots=False,  # создает __slots__ с заданными полями
)
class MyClass(): ...
```
***
Датаклассы не разрешают использование изменяемых типов данных в качестве атрибутов экземпляров (ошибка со встроенными изменяемыми типами, однако контроль пользовательских типов остается за разработчиком).
```python
from dataclasses import dataclass, field

@dataclass
class MyClass:
	# guests: list[str] = []  # ошибка!!!
	guests: list[str] = field(default_factory=list)	
	
	field_kwargs: list = field(
		default=_MISSING_TYPE,
		default_factory=list,
		init=True,  # включать ли в состав __init__
		repr=True,  # использовать ли в __repr__
		compare=True, # использовать ли в методах сравнения
		hash=None,    # включить в вычисление __hash__ (при compare=True)
		metadata=None # пользовательские данные, словарь
	)
```
***
`__post_init__` используется, если поле вычисляется на основании других полей или для проведения проверок и валидаций.
```python
@dataclass
class Member:
	# если не задавать тип, то будет атрибут класса
	handles = set()  # не будет в __init__
	
	# если нужно указать тип, то:
	handles: typing.ClassVar[set[str]] = set()
	
	handle: str = "" # это уже атрибут экземпляра
	other: dataclasses.InitVar[str] = ""  # только в методе __post_init__
	
	def __post_init__(self, other: str):
		print(other)
		if self.handle in self.__class__.handles:
			raise ValueError
		self.__class__.handles.add(self.handle)
```
***
Все рассмотренные классы данных имеют реализованные атрибуты `__match_args__`, поэтому сразу могут использоваться в конструкциях сопоставления.
```python
import typing
class City(typing.NamedTuple):
	continent: str
	name: str
	country: str
	
City.__match_args__  # ('continent', 'name', 'country')

def match_asian_cities(cities: list[City]):
	results = []
	for city in cities:
		match city:
			case City(continent='Asia', country=country):
				results.append(country)
	return results
```
***
- [!] Датаклассы - уклон в сторону статической типизации, потому что без этого они просто не работают (это не будут атрибуты экземпляров).
***
### Ссылки на объекты, изменяемость и повторное использование
**Переменная** - этикетка, а не ящик.
Переменная всегда создается после создания объекта, поэтому правильно говорить "переменная `s` присвоена объекту", а не "объект присвоен переменной `s`".
```python
a = [1, 2]
b = a  # добавляем новую этикетку на объект с этикеткой 'a'
b.append(3)
a      # [1, 2, 3]
```
![[Pasted image 20251006191405.png|400]]
***
**Псевдонимы** - разные переменные для одного объекта.
Оператор `==` вызывает метод `__eq__`, а `is` - сравнивает `id` объектов.
Оператор  `is` чаще всего полезен только при сравнении Singleton объектов. Самый распространенный пример - `None`.
`is` работает быстрее, потому что его нельзя перегрузить, а сама проверка является сравнением двух целых чисел. В остальных же типах `__eq__` перегружен семантикой типа, поэтому работает дольше.
`deepcopy` - создает полную копию объекта, включая полноценное копирование внутренних объектов, а не только ссылок. Проблема циклических ссылок решается сохранением уже скопированных объектов.
***
```python
# pythontutor.com
l1 = [3, [66, 55, 44], (7, 8, 9)]
l2 = list(l1)
l1.append(100)
l1[1].remove(55)
l2[1] += [33, 22]
l2[2] += (10, 11)
```
![[Pasted image 20251006194100.png|500]]
***
Все аргументы функций в python являются *псевдонимами*, то есть аргумент и реальный переданный в функцию объект имеют тот же идентификатор. То есть с помощью него можно изменить исходный объект, если он изменяем (но не может заменить его - подложить не тождественный).
Любое значение по умолчанию вычисляется в момент определения функции (загрузки модуля), а затем становится атрибутом объекта функции, из-за чего если не передавать значение извне - *аргумент всегда будет псевдонимом для значения по умолчанию*.
***
Если вы принимаете изменяемый объект в качестве аргумента, то нужно всегда подумать, можно ли его менять и ожидает ли это клиент. Если не знаете - лучше использовать *защитное копирование* и работать со своей копией объекта (принцип наименьшего удивления).
Небольшое перерасходование ресурсов лучше, чем неизвестная проблема или баг.
***
`del` - не функция, а **директива** языка:
- `del x -> del(x)`, но только потому, что `x == (x)`
- удаляет ссылку, а не объект
	- из-за чего объект может быть удален, если это последняя ссылка
- метод `__del__` вызывается интерпретатором перед удалением объекта, чтобы освободить ресурсы
	- не нужно его писать или вызывать самостоятельно
`open().write()` безопасен! Если не будет ошибок, но лучше все же `with`.
***
```python
t1 = (1, 2, 3)
t1 is tuple(t1)  # True
t1 is t1[:]      # True
# то же самое str / bytes / fronzenset
```
***
```python
a = "a"
b = "a"
a is b  # True
```
**Интернирование** - переменные одинаковых неизменяемых объектов имеют одинаковые ссылки:
- используется для строковых литералов и небольших чисел для избежания дублирования
- нельзя полагаться, потому что логика интернирования не документирована и создана для нужд интерпретатора, поэтому для таких типов лучше `==` всегда