### Модель данных
```python
import collections

# namedtuple используется для конструирования классов без методов
Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:  
	ranks = [str(n) for n in range(2, 11)] + list('JQKA')
	suits = 'spades diamonds clubs hearts'.split()

	def __init__(self):  # инициализация объекта класса
		self._cards = [Card(r, s) for s in self.suits for r in self.ranks]

	def __len__(self):   # получения "длины" объекта
		return len(self._cards)

	def __getitem__(self, position):  # получения элемента через "[]"
		return self._cards[position]
```
***
Если у класса нет метода `__contains__`, то при вызове `in` будет последовательный просмотр.
***
`len()` - не метод, а что-то среднее, потому что для встроенных типов, реализованных на C, длина получается из атрибута `PyVarObject.ob_size`, без фактического вызова. Тогда как для кастомных классов - вызов `__len__`.
***
Чаще всего **специальные методы** вызываются интерпретатором или неявно (с помощью встроенных функций `iter`, `len`, ...).
***
Для строкового представления числа лучше всего реализовать метод `__repr__`, так как при отсутствии `__str__` будет вызван он.
`__repr__` в свою очередь должен максимально приближенно представлять создание объекта, тогда как `__str__` - строку, пригодную для показа пользователю.
***
`__bool__` - булево представление объекта, которое используется при его подстановке в выражения.
По умолчанию пытается вызвать `__bool__`, потом `__len__`, а иначе всегда `True`.
***
**ABC** - abstract base class.
API коллекций представлено ниже:
- `Iterable` - для `for`
- `Sized` - для `len()`
- `Container` - для `in`
- `Collection` - **list / str**
- `Mapping` - **dict / collections.defaultdict**
- `Set` - **set / frozenset**
	- тут реализованы **инфиксные** операторы
![[Pasted image 20250727182108.png|400]]
***
В питоне есть множество специальных методов типа `__*__`, которые нужны для изменения поведения базового функционала.
`__<name>__`, `__r<name>__` - инверсный оператор (когда у первого операнда не реализовано поведение при нужных типах), `__i<name>__` - составное присваивание (`+= / -= / ...`).
***
Благодаря специальный методам в питоне можно сделать так, чтобы пользовательские классы имели все возможности встроенных классов, тогда как например в **Golang** - итерируемые объекты ограничены 5 *магическими* типами.
### Последовательности
Все последовательности в питоне имеют примерно одинаковый набор операций, благодаря хорошим интерфейсам.
***
**Контейнерные последовательности** - `list` / `tuple` / `collections.deque`, хранят в памяти ссылки на объекты любого типа.
**Плоские последовательности** - `str` / `bytes` / `array.array`, хранят сами значения в памяти, занятой последовательностью, а не как отдельные объекты.
- поэтому компактнее и занимают меньше места, но могут содержать только значения примитивных типов (байты, числа, строки)
- занимает меньше места, потому что каждый объект в питоне имеет заголовок с метаданными (счетчик ссылок, указатель на тип, значение): в кортеже таких заголовков и самих объектов будет много, а у массива всего один
![[Pasted image 20250727183519.png|400]]
***
**Изменяемые последовательности** - `list` / `bytearray` / `array.array` / `collections.deque`
**Неизменяемые последовательности** - `tuple` / `str` / `bytes`
![[Pasted image 20250727203830.png|400]]
Встроенные тип последовательностей не наследуются от этих классов, а являются лишь *виртуальным подклассами*:
```python
from collections import abc
issubclass(tuple, abc.Sequence)        # True
issubclass(list, abc.MutableSequence)  # True
```
***
**Списковые включения** - синтаксический сахар для создания списков по итерируемым объектам. Можно использовать сразу несколько циклов `for` внутри одного включения, при этом порядок будет такой же, как и при вложенном написании этих циклов друг за другом (то есть последний пройдет раньше всех).
Списковое включение не медленнее функций высшего порядка `filter + map`.
```python
codes = [ord(sym) for sym in "ABCD" if ord(sym) > 70] # списковое включение
codes_gen = (ord(symbol) for symbol in "ABCD")        # генераторное выражение

with_filter = list(filter(lambda c: c > 127, map(ord, symbols)))
```
**Генераторное выражение** - экономит память, так как отдает элементы по одному, вместо того, чтобы строить список сразу.
```python
import array

# можно убирать лишние скобки, если генератор - единственный аргумент
tuple(ord(symbol) for symbol in symbols)
array.array('I', (ord(symbol) for symbol in symbols))  # тут скобки обязательно
```
***
**Кортежи** - в первую очередь последовательность
- как запись: каждый элемент содержит данные одного поля, а его позиция определяет его семантику
- неизменяемый список
	- его длина не изменяется
	- потребляет меньше памяти
		- байт-код сразу кладет данные в константу, тогда как каждый элемент списка сначала идет в стек как отдельная константа, и только потом в сам список
		- выделяется ровное количество памяти, без амортизации
		- кортеж хранит массив ссылок в себе, тогда как список хранит ссылку на массив ссылок, чтобы при перезаписи поменять его
- ссылки на объекты неизменны, но сами объекты по ссылкам могут быть изменены
	- то есть он хэшируем, только если все внутри тоже
***
**Распаковка** - удобный способ получения объектов из другого итерируемого объекта, без использования индексов и циклов.
```python
# звездочку можно ставить в любом месте
a, b, *rest = range(5)         # (0, 1, [2, 3, 4])

# распаковка вложенного объекта
a, b, (c, d) = [1, 2, (3, 4)]  # (1, 2, 3, 4)
```
***
**Сопоставление с последовательностями-образцами** - удобный инструмент деструктуризации и сравнения.
`str`, `bytes`, `bytearray` - не деструктуризируются, чтобы избежать ошибок. Если нужно, можно создать из них кортеж: `tuple("asd")`.
Это пример *декларативного* программирования: мы обозначаем, "что" хотим сопоставить, а не "как".
```python
# в этом примере идет деструктуризация и сравнение первого элемента (имени),
# пропуск двух элементов, и сравнение координат с типами;
# в контекст сопоставления это не конструктор, а сравнение типа
match record:
	case ["John", _, _, (float(lat), float(lon))] if lon <= 0:
		print(f"{lat}:{lon}")
```
***
Для среза `seq[i:j]` вызывается `seq.__getitem__(slice(i, j))`.
```python
l = [1, 2]
l *= 2  # [1, 2, 1, 2]
t = (1, 2)
t *= 2  # (1, 2, 1, 2), но ссылка станет другой, потому что нет __imul__
```
***
В python принято, что функции, изменяющие сам объект, возвращают `None`: например, `list.sort()` или `random.shuffle`.
Для сортировки python использует `Timsort` (Tim - автор сортировки и дзена питона):
- сортировка вставками при сильном разделении на маленькие участки;
- сортировка слиянием (merge sort) - при больших объемах.
Функция далее позволяет держать последовательность отсортированной при вставках, однако расходует **O(log(n))** на поиск места и **O(n)** на вставку.
```python
import bisect

a = [1, 3]
bisect.insort(2)  # [1, 2, 3]
```
***
`array.array` намного выгоднее при хранении примитивных типов, потому что хранит запакованные байты, а не сами объекты, причем имеет функцию по загрузке и выгрузке себя в двоичный файл, что в разы быстрее, чем записывать и читать из текстового файла.
```python
from array import array

octets = array('B', range(6))
m1 = memoryview(octets)    # m.tolist() => [0, 1, 2, 3, 4, 5]
m2 = m1.cast('B', [2, 3])  # m2.tolist() => [[0, 1, 2], [3, 4, 5]]
```
***
`deque` - отличная потокобезопасная альтернатива `list`, если нужно постоянно вставлять и читать значения из двух концов (*double ended queue*).
`append` и `popleft` атомарны.
Большой минус - операции удаления из середины идет медленно.
```python
from collections import deque

d = deque(range(5), maxlen=5)  # maxlen достигнут => -1 элемент с другого конца
d.extendleft([10, 20, 30, 40])   # deque([40, 30, 20, 10, 0], maxlen=5)
```
### Словари и множества
*Словари* - краеугольный камень питона. Пространства имен, атрибуты объектов, именованные аргументы функций и многое другое хранится в них.
Поэтому они очень хорошо оптимизированы и предлагают широкий ассортимент функций для `dict`, `set`, `frozenset`.
***
Строки в **хэш-таблице** - **бакеты**.
☢️ Оптимизации:
- использование **пробинга** при совпадении хэшей;
- после определенного количества коллизий питон выбирает псевдорандомный индекс и идет вставлять туда, потому что иначе увеличивается количество проб индексов в цикле;
- если бакеты заполнены на `2/3`, то размер удваивается
![[Pasted image 20250730161647.png|600]]
***
В **словарях** схема немного другая (но такая же при коллизиях):
- хранить все значения в бакете не оптимально, потому что далеко не все они заполнены, при этом место все равно выделено --> бакеты хранятся отдельно и содержат только индекс строки из массива
	- [u] место в массиве выделяет оптимальнее, только при реальном добавлении элементов
	- [u] сохраняется порядок вставки объектов в словарь
		- но не сверяет порядок ключей при сравнении словарей;
		- хуже справляется, когда идет переупорядочивание;
![[Pasted image 20250730211033.png]]
***
```python
# словарное включение
squares = {i: i ** 2 for i in range(3) if i % 2 == 0}  # {0: 0, 2: 4}

# распаковака именованных аргументов в функциях
func(**{'a': 1}, b=2, **{'c': 3})

# объединения словарей, при этом при совпадении ключей - возьмем последний
{'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}}

# объединение через __or__, __ior__
d1 = {"a": 1}
d2 = {"b": 2}
d1 | d2   # {"a": 1, "b": 2} => новый словарь
d1 |= d2  # d1 = {"a": 1, "b": 2}
```
***
**Сопоставление с образцом**
- порядок ключей в образце не имеет значения;
- могут быть ключи, которых в образце нет, но все равно подойдет;
```python
def get_creators(record: dict) -> list:
	match record:
		case {'type': 'book', 'api': 2, 'authors': [*names]}:
			return names
		case {'type': 'book', 'api': 1, 'author': name}:
			return [name]
		case {'type': 'book', **other}:
			raise ValueError(f'Incorrect book: {other}')
		case _:
			raise ValueError(f'Invalid record: {record! r}')
```
***
**Хэшируемый объект** - имеет хеш-код, который не изменяется на протяжении всего времени его жизни (у него должен быть метод `__hash__()`), и допускает сравнение с другими объектами (у него должен быть метод `__eq__()`). Если в результате сравнения хешируемых объектов оказывается, что они равны, то и их хеш-коды должны быть равны.
***
Стандартный базовые классы для отображений:
```python
from collections.abc import Mapping, MutableMapping
```
![[Pasted image 20250730213250.png|500]]
***
Метод `__missing__` нужно использовать, если хочется поменять поведение при отсутствии ключа в словаре.
```python
from collections import defaultdict, ChainMap, Counter

index = defaultdict(list)
index["key"].append("some value")

index = {}
index.setdefault("key", []).append("some value")

# объединение словарей, при этом хранение только ссылок
# добавление идет только в первый словарь
pylookupdict = ChainMap(locals(), globals(), vars(builtins))

ct = Counter('abracadabra')  # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
ct["F"]  # => 0
```
***
Если нужно создать **свой** словарь, то лучше использовать `collections.UserDict`:
- хранит сами значение в словаре в атрибуте `data`;
- т.е. использует композицию;
```python
class StrKeyDict(collections.UserDict):
	def __missing__(self, key):
		if isinstance(key, str):
			raise KeyError(key) return self[str(key)]

	def __setitem__(self, key, item):
		self.data[str(key)] = item
```
***
Ключи и значения словаря являются отдельными типами данных, которые не дублируют информацию, а являются неизменяемыми проекциями реальных данных.
Эти классы нельзя создать и использоваться, они доступны только из словаря и нужны для операций над внутренними множествами словарей (`.keys` и `.items` очень похожи на `frozenset`).
```python
d = dict()
d.keys()   # 'dict_keys'
d.values() # 'dict_values'
d.items()  # 'dict_items'
```
### Множества
Набор уникальных объектов, и главное использование - устранение дубликатов.
Элементы должны быть хешируемыми, тогда как сам `set` - не хешируемый.
`frozenset` - хешируемый.
```python
s = set()      # создание пустого множества
s = {1, 2, 3}  # создание непустого множества, выглядит в точности как математическая нотация
s = {chr(i) for i in range(32, 65)}  # множественное включение
```
***
- нельзя верить порядку вставки - он не сохраняется
- после заполнения `2/3` множество переносится, и порядок теряется
***
![[Pasted image 20250830114707.png]]
```python
from collections.abc import Collectio, Set, MutableSet
```
***
```python
&       # пересечение
|       # объединение
-       # разность
^       # симметрическая разность
in      # проверка на вхождение
<=      # проверка на подмножество
>=      # проверка на надмножество
add     # добавить
clear   # стереть все
copy    # поверхностная копия
discard # удалить элемент, если есть
pop     # удалить и вернуть элемент
remove  # удалять элемент, возбудив исключение при отсутствии
```
### Unicode-текст и байты
