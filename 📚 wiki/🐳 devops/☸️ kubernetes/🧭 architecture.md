### База
- Задачей **kubernetes** является координация кластера компьютеров, работающего как одно целое
- Абстрактные объекты позволяют развертывать контейнеризованные приложения в кластер, не привязывая их к отдельным машинам - неизменяемость (**immutable**). То есть инфраструктура в этом случае - цельный артефакт, который можно запустить / остановить как контейнер
- Имеет механизм самовосстановления (**self-healing**) - каждый компонент отслеживает и поддерживает состояние инфраструктуры
- Декларативность - не нужно писать, "как" развернуть что-то, только желаемое состояние
- Каждый компонент инфраструктуры не зависит от других, полагается только на SLA
![[Pasted image 20250705211646.png]]
### Resources
- **Limits** - максимально количество ресурсов, которое под может использовать
- **Requests** - резервируемые ресурсы пода, которые только для него
***
### Архитектура кластера
![[Pasted image 20250703210427.png]]
##### Control Panel
Ведущий узел, который управляем кластером.
Он координирует все процессы в кластере: планирование запуска приложений, сохранение требуемого состояния (например, запуск нового **пода**, если количество реплик не достигнуто), масштабирование и обновление.
Компоненты панели управления могут быть развернуты на любой машине кластера.
*Составные части:*
- **kube-apiserver** - сервер для предоставления Kubernetes API. Фронтенд для клиентов панели управления. Может быть и создан для горизонтального масштабирования. Единственный компонент, который напрямую общается с `etcd`. Занимается аутентификацией и авторизацией как самих приложений, так и пользователей. Не выполняет работы, а только записывает и раздает информацию
- **etcd** - консистентное доступное хранилище ключ-значений для хранения всей информации о кластере (точка правды)
- **kube-scheduler** - компонента, которая наблюдает за создаваемыми **подами** без назначенной **ноды**, и выбирает ноду для его запуска.
	- учитывает QoS и другие настройки
	- 
- **kube-controller-manager** - компонента для запуска процессов управления. Каждый контроллер запускается как отдельный процесс, но все они стартует одним бинарником. Не создает сами поды, а только их конкретное описание из шаблона манифеста
	- **node controller** - отвечает за нахождение и исправление упавших нод
	- **job controller** - следит за джобами, создает поды и исполняет нужные задачи до исполнения
	- **endpoint slice controller** - создает связь между сервисами и подами
	- **service account controller** - создает сервисные аккаунты для новых неймпейсов
	- сборщик мусора
- **cloud-controller-manager** - компонента для взаимодействия с облачным провайдером
##### Node
Машины, на которых выполняются приложения. Виртуальная машина или физическая машина в кластере. Продуктовое окружение должно иметь минимум три ноды, потому что если одна мастер-нода выйдет из строя все будет утеряно. Для уменьшения риска должны быть хотя бы две контрольные панели.
- **kubelet** - является агентом для управления и взаимодействия с панелью управления. Получает настройки подов и проверяет+чинит, что поды запущены и живы. Не трогает контейнеры, которые созданы не кубером.
- **kube-proxy** - создает и управляет настройками сети на нодах.
- **container runtime** - компонента для оптимального запуска контейнеров. Управляет всем жизненным циклом контейнеров. Поддерживает `containerd, CRI-O` и прочее.
При деплое приложения контрольная панель создает контейнеры. Она планирует запуск контейнеры на нодах кластера. Инструмента уровня нод (например **kubelet**, используют API, которую панель управления предоставляет). Обычные пользователи также могут использовать это API.
![[Pasted image 20250914191232.png]]
***
### Хранение данных
**Good State - Dead State (Stateless)**
Данные лучше хранить в БД, а файлы в S3