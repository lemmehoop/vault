**Docker** - это инструмент контейнеризации. Он позволяет запускать приложения обособленно от системы, со своим окружением и прочим, и, так как это процессы, им не нужны гипервизоры как для виртуальных машин.
### Основа
**Namespaces** - ограниченные процессы и их номера. Монтирование дисков и пользователи.
Они создают разные виды структуры процессов для разных групп.
Тут есть небольшой оверхед: для процессов в неймспейсах есть два PID (внутри и для хоста), но тяжело назвать это значимой сложностью.
```bash
docker run -ti --rm docker:28-dind sh
apk add --no-cache bash

ls -l /proc/$$/ns  # вывод неймспейсов текущего процесса (основные: net - cеть, pid - номера процессов, mnt - файловая структураб uts - хостейнмы, user - маппинг пользователей)
lsns  # вывод всех возможных

unshare -u bash  # переносим bash в другой НС для хостнеймов
hostname <new name>  # не повлияет на настоящий хостнейм, потому что назодимся в другой спейсе

# команда далее отрезает весь процесс: будет всего один процесс, не будет сети
unshare --pid --fork --net --mount-proc /bin/bash
lsns  # покажет, что мы создали

nsenter -t <pid of process with ns> --net --pid --mount --ipc --uts sh
```

**CGroups** - управляют ресурсами: прикрутить ограничения по памяти, сети, процессору и прочему.
Тут тоже есть небольшой оверхед: если ограничить память, то за ней нужно следить.
```bash
docker run --name <name> --memory=100m --cpus=".2" <image> -d  # запускаем контейнер с ограничениями (.2 - 0.2 секунды от целой секунды)

systemd-cgls  # увидеть все группы (берем SHA-256 процесса)
ls -l /sys/fs/cgroup  # все группы

cat /proc/<process id>/cgroup  # найти группу процесса
cd /sys/fs/cgroup/<выхлоп прошлой команды>  # тут будут лимиты
```
### Архитектура
![[Pasted image 20250704195033.png]]
##### Docker Daemon
Создает образы, скачивает, запускает все.
Создает сеть между контейнерами.
Собирает логи контейнеров.
##### Docker CLI
Утилита для взаимодействия с демоном. Может работать по сети с нелокальным докером.
##### Image / образ
**Dockerfile** - инструкция по созданию.
Каждая команда - новый **слой**. Если будет создаваться новый слой - предыдущие слои будут переиспользоваться и будет оптимизация.
Каждый слой во время сборки - независимый образ диска. Если в одном слое будет файл - не факт, что он будет в другом.
Это схема библиотек и зависимостей, необходимых в контейнере, для запуска приложения. Фактически - образ файловой системы.
**Docker Registry** - хранилище образов.
##### Container
Изолированный процесс. Содержит в себе все нужное для работы.
Best practice: 1 процесс - 1 контейнер. Лучше не запускать больше: два процесса, PID=1 и PID=2. Если второй умрет - контейнер не упадет и мы не узнаем об этом.
##### Volume
Это та часть системы внутри контейнера, которая должно быть доступна на хостовой ОС. То есть это к тому же и постоянное хранилище. Присоединяется через `mount`.
##### Network
Виртуальные адаптеры Ethernet со своими локально уникальными подсетями внутри сети докера. Нужны для того, чтобы контейнеры были связаны между собой, но не со всем остальным.
- bridge - в ней по умолчанию находятся все контейнеры
- overlay - сеть для использования сервисами для связи с контейнерами
- host - изоляция контейнера, чтобы только хостовая система имела к нему доступ
- none - отключение всех сетей
- macvlan - привязка настоящего мак-адреса к контейнеру, чтобы он имел выход в сеть
##### Docker Compose
Утилита для запуска нескольких контейнеров с помощью одного файла.
Сразу есть общая сеть и имена, по которым можно обращаться.
Чтобы было проще задавать и управлять приложениями, которые запускают сразу несколько контейнеров
- у них из коробки будет общая сеть
- одной командой будут запускаться все
Можно делать так:
```bash
docker compose -f <first.yml> -f <second.yml> up --exit-code-from <service>
```

### Best practice
- там где можно - лучше не использовать `RUN` много раз, потому что это лишняя память и шаги в сборке
- очищать кэш пакетных менеджеров
- команды, которые могут что-то менять (изменяемые слои), ставить ниже слоев, которые будут меняться реже
- всегда ставить конкретные теги, чтобы обеспечить идемпотентность