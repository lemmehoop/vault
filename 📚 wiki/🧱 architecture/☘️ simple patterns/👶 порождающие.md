### Фабричный метод
Порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
***
> Основная идея - код создания объекта становится **инкапсулирован** внутри фабрики, а клиентский код будет лишь вызывать метод интерфейса. В самой конкретной фабрике можно будет менять этот метод как угодно и возвращать что угодно, что удовлетворяет интерфейсу.
***
```python
from typing import Protocol, Literal
  
class User(Protocol):  
    def get_permissions(self) -> list[str]: ...  
  
class SimpleUser(User):  
    def get_permissions(self) -> list[str]:  
        return ["read"]  
   
class Admin(User):  
    def get_permissions(self) -> list[str]:  
        return ["read", "write", "delete"]  
    
class Factory(Protocol):  
    def create_user(self) -> User: ...  
    
class SimpleUserFactory(Factory):  
    def create_user(self) -> User:  
        # тут будет инкапсулированная логика по созданию простого пользователя  
        return SimpleUser()  
    
class AdminFactory(Factory):  
    def create_user(self) -> User:  
        # тут будет логика по созданию админа  
		# например, сходить в какой-то сервис и выдать дополнительные права              # настроить админ-панель и прочие действия        
		return Admin()
```
### Абстрактная фабрика
Паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
То есть смысл в том, что есть "абстрактная фабрика", использующая интерфейсы и сама являющаяся интерфейсом, которой будут пользоваться клиенты, при это конкретные реализации возвращают конкретные реализации интерфейсов.
***
> Основная идея - объединить создание связанных объектов и вынести удобный интерфейс для их создания.
***
![[Pasted image 20250717201719.png|500]]
### Строитель
Позволяет создавать сложные объекты пошагово. Дает возможность использовать один и тот же код строительства для получения разных представлений объектов.
***
> Решает проблему большого количества параметров в конструкторе класса.
***
```python
from functools import partial  
from typing import Protocol  
  
class Drink:  
    def __init__(self, color: str | None, logo: str | None) -> None:  
        self.color = color  
        self.logo = logo  
    
class DrinkBuilder(Protocol):  
    def set_color(self) -> None: ...  
  
    def set_logo(self) -> None: ...  
  
    def get_result(self) -> Drink: ...  
    
class FantaBuilder(DrinkBuilder):  
    def __init__(self) -> None:  
        self.partial = partial(Drink)  
  
    def set_color(self) -> None:  
        self.partial = partial(self.partial, color="orange")  
  
    def set_logo(self) -> None:  
        self.partial = partial(self.partial, logo="fanta")  
  
    def get_result(self) -> Drink:  
        return self.partial()  
  
class SpriteBuilder(DrinkBuilder):  
    def __init__(self) -> None:  
        self.partial = partial(Drink)  
  
    def set_color(self) -> None:  
        self.partial = partial(self.partial, color=None)  
  
    def set_logo(self) -> None:  
        self.partial = partial(self.partial, logo="sprite")  
  
    def get_result(self) -> Drink:  
        return self.partial()  
  
class Director:  
    def __init__(self, builder: DrinkBuilder) -> None:  
        self.builder = builder  
  
    def build_drink(self) -> Drink:  
        self.builder.set_color()  
        self.builder.set_logo()  
  
        return self.builder.get_result()
```
### Прототип
Позволяет скопировать объекты, не вдаваясь в подробности реализации.
***
> Нужен для полноценного копирования объектов, даже если у них есть приватные атрибуты, т.к. копирование делегируется самим классам. Не имеет полноценного применения в python, если не нужно дополнительная логика в **__deepcopy__**
***
### Singletone (одиночка)
Гарантирование того, что у класса есть только один экземпляр и предоставление к нему глобального доступа.
***
> Нужен для того, чтобы например не плодить сущности, или когда по БП у класса должен быть только один объект.
***
```python
class SingletonMeta(type):  
    _instances = {}  
  
    def __call__(cls, *args, **kwargs):  
        if cls not in cls._instances:  
            cls._instances[cls] = super().__call__(*args, **kwargs)  
        return cls._instances[cls]  
  
  
class SingletonClass(metaclass=SingletonMeta):  
    def __init__(self, value):  
        self.value = value
```