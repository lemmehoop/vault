**Действия** - зависят от того, сколько раз и когда они выполнялись. Так называемые функции с побочными эффектами (отправка электронной почты, чтение из базы данных)
**Вычисления** - преобразуют ввод в вывод. Так называемые чистые функции (поиск максимального числа, проверка действительности почтового адреса)
**Данные** - факты, относящиеся к событиям (адрес электронной почты, денежная сумма, полученная из банка)

Порядок действий:
1. Анализ задачи (надо понять, на что обращать больше внимания, определить данные и решения, которые необходимо принять)
2. Программирование решения (разделять три понятия в коде и всегда искать возможность перейти от действий к вычислениям)
3. Чтение кода (всегда ищем возможности улучшить код)

**Навыки не должны основываться на возможностях языка!!!**

Лучше всего генерировать данные отдельно от их использования. Аналогия: строим список покупок до похода в магазин, чтобы потом в магазине ничего не вспоминать.
Почему так лучше? Потому что намного проще тестировать систему, результатом работы которой является список каких-то элементов, а не отправка почты.

Типичный порядок работы:
1. Данные
2. Генерация данных для действий с помощью вычислений
3. Выполнение действий

Главное и основное - не связывать бизнес-правила с тем, что потом нельзя протестировать. Лучше отделить то, что делает и проверяет бизнес: тогда и тестировать будет проще, и код будет легче переиспользоваться.

Плохая часть состоит в том, что если есть где-то пустить действие, то оно расползется, и в итоге весь код будет состоять только из действий.

**Явным** вводом для функции являются передаваемые аргументы. Все, что появляется иначе (например считывание глобальной переменной) - **неявный**. Так же и с выводом: явный тот, что возвращается, а отправка чего-то, вывод в консоль, изменение глобальной переменной - неявный вывод.

#### Извлечение вычислений
1. Выбор и извлечение кода для вычисления
2. Идентификация неявного вводы и вывода
3. Преобразование вводы в аргументы и вывода в возвращаемые значения

Убирая неявный ввод и вывод мы делаем компоненту модульной. То есть она не будет зависеть от состояния и характеристик окружающих элементов и при необходимости будет хорошо использоваться в других местах.

##### Суть проектирования в разделении
- простота повторного использования - меньшие и простые функции проще использовать заново. Они выполняют меньше работы и делают меньше предположений
- простота сопровождения - проще понять, меньше кода - из правильность (или ошибочность очевидна)
- простота тестирования - если функция делает что-то одно, то и тестировать эту обязанность проще

Например: при добавлении элемента в корзину не обязательно держать создание нового элемента и его добавление в одном месте. Если сделать метод, который вернет созданный элемент, то функционал можно будет развивать отдельно, не смотря на то, как создает элемент.

При разделении кода, когда функции имеют только одну обязанность, они легко группируются на базе концепций (будто то бизнес-правила или что-то другое).

Для лучшей архитектуры можно применять *копирование при записи*: т.е. изменять не сам объект, а делать его копию, изменять и возвращать ее.

##### Копирование при записи
- операции чтения изменяемых данных являются действиями
- операция записи делает данные изменяемыми
- если данные не используются для записи, то они являются неизменяемыми (копирование при записи как раз это нам и дает)
- операции чтения неизменяемых структур данных являются вычислениями
- преобразование операция записи в операции чтения увеличивает долю кода в вычислениях

Это называется **паттерн замены**. То есть саму переменную мы не изменяем, а на ее место ставим новую, которую сделали из ее копии.

*Структурное совместное использование* - ситуация, при которой вложенные структуры данных ссылаются на одну и ту же внутреннюю структуру данных (то есть при поверхностном копировании)

*Унаследованный код* - существующий код, который не может быть заменен на данный момент (возможно старый и плохой). И приходиться работать с ним в том виде, в котором он доступен.

##### Защитное копирование
При входе данных в безопасную из ненадежного кода нельзя полагать, что данные неизменяемые. Из-за этого мы сразу же делаем глубокую копию и отбрасываем изменяемый оригинал. Так как только доверенный код располагает ссылкой на эту копию, она является неизменяемой. Таким образом организуется защита при входе в безопасную зону. Точно так же, при выходе так же создается глубокая копия, чтобы защитить наш оригинал.

**Правила**:
1. копируйте данные, выходящие из вашего кода (передаем копию ненадежному коду)
2. копируйте данные, входящие в ваш код (создаем глубокую копию и используем ее в нашем коде)

##### Многоуровневое проектирование
**Проектирование программной системы** - применение эстетических представлений для принятия решений из области программирования, упрощающих программирование, тестирование и сопровождение продукта.

*Проклятие эксперта* - даже если хорошо что-то умеешь, не можешь объяснить, что именно делаешь. Есть прекрасно проработанная модель, но нет средств для описания этой модели для других.

**Паттерн прямолинейной реализации**
- прямолинейные реализации вызывают функции примерно одного уровня абстракции (например функция, которая проверяет, есть ли скидка на товар, не должна проверять наличие товара в корзине перебором массива, слишком низкоуровневая задача)
- возможность игнорировать подробности - хороший признак
- прямолинейный код решает задачу на одном уровне детализации
- чаще всего, код плохо читается, потому что его приходится понимать на разных уровнях детализации. Прямолинейные реализации стараются сократить набор уровней детализации, понимание которых необходимо для чтения кода
- не достаточно просто скрыть малопонятные части за "вспомогательными функциями". При многоуровневом проектировании каждый уровень должен быть прямолинейным
**Абстрактный барьер**
- уровень функций, скрывающий реализацию, чтобы при использовании этих функций вы могли полностью забыть о том, как они реализованы
- то есть это полезно, когда разные команды / люди работают с кодом, потому что одни могут спокойно вносить изменения в реализацию, не говоря другим, а другим не нужно париться о том, как именно эта функция работает
- самый яркий пример - API, потому что тем, кто использует его совершенно не важно, как именно эти данные получаются
- *абстракция* - какие подробности я могу игнорировать?
- то есть учитывая паттерн прямолинейно реализации, это значит, что есть какой-то уровень реализации, который не пересекается стрелками с уровня выше на уровни ниже него
- когда стоит использовать
	- для упрощения изменения реализации (когда вы не знаете или наоборот знаете, что реализация низкого уровня может измениться)
	- для упрощения чтения и написания кода (если правильно выбрать скрываемые подробности, то с кодом будет легче работать)
	- для умственной концентрации на имеющейся задаче (они упрощают анализ задачи, потому что не нужно беспокоиться о многочисленных подробностях; некоторые подробности становятся несущественными для той задачи, которую вы решаете на данный момент)
