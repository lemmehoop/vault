### SRP
**Single Responsibility Principle**
Принцип единственной ответственности - каждый модуль систему имеет одну и только одну причину для изменения.
Этот принцип не означает, что каждый модуль отвечает за что-то одно: такой принцип есть, но он использует на низком уровне реализации, когда происходит функциональная декомпозиция.
Сам же принцип гласит, что модуль должен отвечать за одного и только одного актора.
Связность - как раз таки определяет, что модуль отвечает за одного актора.
##### Пример нарушения принципа
- **непреднамеренное дублирование** - допустим есть класс Employee. У него есть методы, которые считают количество рабочих часов и зарплату. Тут то и кроется проблема - первый метод используется бухгалтерией, а второй - менеджером. Если оба этих метода используют один и тот же функционал, то можно будет пропустить момент, когда одна сторона поменяет код, который влияет на другую.
- **решение** - разбиение функционала на два раздельных класса и использования паттерна *facade*.
### OCP
**Open-Closed Principle**
Принцип открытости-закрытости - простая для изменения система должна предусматривать возможность изменения ее поведения добавлением нового, но никак не изменением существующего.
Иными словами - должна иметься возможность расширения функционала сущностей без их изменения.
Т.е. нужно распределить сущности и интерфейсы так, чтобы при необходимости добавления нового функционала можно было создать новый класс с нужным интерфейсом и использовать его там, где использовался другой, тем самым ограничив часть с бизнес-логикой.
### LSP
**Liskov Substitution Principle**
Принцип подстановки Барбары Лисков - для создания программных систем из взаимозаменяемых частей эти части должны соответствовать контракту, который позволяет заменять эти части друг другом.
Т.е. производный объект не должен сужать функциональность родительского класса.
Так же и на архитектурном уровне - должна быть полная совместимость нового функционала с заданным интерфейсом.
### ISP
**Interface Segregation Principle**
Принцип разделения интерфейсов - призывает избегать зависимости от всего, что не используется.
Нельзя создавать сущности и модули, которые держат в себе больше, чем нужно.
### DIP
**Dependency Inversion Principle**
Принцип инверсии зависимости - код, реализующий высокоуровневую политику не должен зависеть от кода, реализующего низкоуровневые детали.
В архитектуре должны быть стабильные абстракции: при их изменение меняется и реализация, но не наоборот.
###### Набор правил
- *не ссылаться на изменчивые конкретные классы* - ссылаться на абстрактные интерфейсы
- *не наследуйте переменчивые классы* - прямо продолжение первого правила
- *не переопределяйте конкретные функции* - если нужно, чтобы функция работала иначе, то лучше сделать ее абстрактной и сделать две ее реализации
- *не ссылайте на имена конкретных изменчивых сущностей*
Тут же стоит рассказать и о паттерне **абстрактная фабрика**: если внутри какого-то класса нужен объект другого класса, то можно сделать фабрику с интерфейсом, который позволяет его создать и вернуть. Тогда как основной класс будет работать только с интерфейсами, сами реализации будут сокрыты внутри абстрактной фабрики и необходимого класса.