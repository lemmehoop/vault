##### Структурное программирование
Накладывает ограничение на прямую передачу управления (условия, циклы и прочее).
Функциональная декомпозиция - один из лучших приемов построения архитектуры.
Мы не можем доказать правильность работы кода, но можем попытаться доказать, что он работает неправильно - и это одна из главных ценностей структурного программирования.
##### ООП
Накладывает ограничение на косвенную передачу управления (благодаря полиморфизму).
**Инкапсуляция** - возможность очертить круг связанных функций и данных, которые за пределами этого круга невидимы и доступны только некоторые функции (те самые *public, protected and private*). На самом деле, большинство языков вообще почти не имеют принудительной инкапсуляции. 
**Наследование** - по сути своей, лишь повторное объявление группы переменных и функций в ограниченной области видимости (переиспользование кода).
**Полиморфизм** - применение указателей на функции. Т.е. основной код может не зависеть от реализации какого-либо модуля, если этот модуль поддерживает необходимый интерфейс!
**Инверсия зависимости** - изменение косвенного потока управления. Если раньше весь поток управления шел сверху вниз (т.е. от модули высших уровне четко вызывали функции нижних уровней по порядку в одну сторону), то с появлением инверсии зависимости появилось возможность в исходном коде вызывать функции из интерфейса, которая в свою очередь реализована в другом модуле. Во время самого выполнения кода это не имеет никакого значения, но при построении кода и архитектуры открывает большие возможности.
Что можно с помощью этого сделать? Можно полностью зависеть только от бизнес правил: правила вызывают интерфейсы, а БД и пользовательский интерфейс будут своего рода плагинами, которые этот интерфейс поддерживают. Таким образом, компонент с БП не будет зависеть от компонентов ПИ и базы данных. Таким образом, появляется возможность создавать и разворачивать эти компоненты по отдельности, разным командами.
##### Функциональное программирование
Накладывает ограничение на присваивание и изменяемость.
Почему неизменяемость важна с точки зрения архитектуры? Ответ прост - у нас не будет *race condition* и *deadlocks*. Ведь эти проблемы связаны именно с изменяемостью данных.
Но тут существует ограничение - для такой работы приложения нужно очень много ресурсов, ведь мы собираемся не хранить изменяемые данные, а вычислять их при необходимости (например, не хранить текущий счет клиента, а лишь добавлять новые транзакции: тогда не будет обновления и удаления данных, а текущий счет будет вычисляться суммой всех транзакций).
А польза для нас в том, что правильно организованные приложения должны делиться на компоненты, которые могут меняться и не могут.