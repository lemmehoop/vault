**Плавающее обновление** - rolling update, обновление, при котором изменения накатываются постепенно, не затрагивая сразу все машины. Таким образом, проверяется работоспособность и снижается время простоя.

**Обратная совместимость** - более новый код способен читать данные, записанные более старым.
**Прямая совместимость** - более старый код способен читать данные, записанные более новым.
### Форматы данных
##### Языковые
Ориентированные на конкретный язык программирования (например *pickle* в Python) форматы данных не могут обеспечить прямую и обратные совместимости и работают только на своем языке. Но для правильной десериализации нужны правильные версии классов и версий библиотек + существует угроза запуска произвольного кода.
##### Текстовые
Текстовые форматы (такие как *JSON, CSV, XML*) широко распространены и способные поддерживать обратную совместимость. В них есть хорошие способы описания схем, иногда полезные, а иногда даже лишние (тут есть проблемы с типами данных, например, числами и двоичными строками).
##### Двоичные
Основанные на двоичных схемах форматы (такие как *Protocol Buffer*) позволяют выполнять сжатое и эффективное кодирование с четко определенной семантикой и обратной и прямой совместимости. Их схемы полезны для документирования и генерации кода в языках программирования со статической типизацией. Но самый большой недостаток: данные необходимо десериализовывать, чтобы люди смогли их читать.

Эволюция на примере **protobuf**:
- Так как в кодировании не учитываются имена полей, а лишь назначенные им теги, то *можно добавлять поля* с новыми тегами. Старый код будет их просто игнорировать, поэтому достигается *прямая совместимость*.
- При наличие у всех полей уникальных тегов новый код всегда сможет читать старые данные. Единственное - *нельзя сделать новое поле обязательным*, потому что старый код его не напишет. Но, *можно добавить значение по умолчанию*. За счет этого достигается *обратная совместимость*.
- Нельзя удалять обязательные поля, потому что старый код будет его ждать, а не получит от нового. Потеряется прямая совместимость.

Основные плюсы:
- компактнее, потому что не содержат названия полей в схемах
- всегда актуальная документация, тогда как тестовые схемы могут быть оторваны от реальности
- генерация кода из схемы
### Режимы движения потоков данных
##### Через базу данных
Один процесс кодирует и данные (пишет их в базу), а другой - читает и декодирует.
Можно воспринимать как отправку данных самому себе в будущем, то есть новая версия приложения в дальнейшем прочитает данные, записанные старым кодом.

Проблемы с совместимостью, которые чаще всего решаются дата-миграциями.
##### RPC и REST API
Клиент кодирует запрос, сервер декодирует запрос, кодирует ответ, а затем уже клиент декодирует ответ.

API дает инкапсуляцию того, что клиенты могут и не могут делать.
REST - подход к проектированию, основанный на принципах HTTP. Акцент на простых форматах данных, применении URL для идентификации ресурсов и использование возможностей HTTP: кэш, аутентификации и согласования контента.

RPC - remote procedure call, попытка сделать вызова сетевых ресурсов так же, как это происходило бы локально.
Проблемы:
- сетевая непредсказуемость
- отсутствие *идемпотентности*
- временные задержки
- невозможность использования ссылок, как при локальном вызове
**gRPC** - реализация RPC с использованием *protocol buffers*.
##### Асинхронная передача
С помощью брокеров сообщений. Узлы взаимодействуют путем отправки друг другу сообщений, кодируемых отправителем и декодируемых получателем.

Основные плюсы:
- служит в качестве буфера в случае недоступности или перегруженности получателя, а следовательно, повышает надежность
- автоматическая отправка сообщений сбойным процессам и исключает потерю сообщений
- не нужно знать IP получателя
- отправка одного сообщения сразу нескольким получателям
- расцепляет отправителя с получателем: отправитель лишь публикует сообщения и не волнуется, кто их получит, когда и как

*Дискуссии (очереди)* обеспечиваю односторонний поток данных. Совместимость напрямую зависит от того, какой метод описания схемы сериализации используется.