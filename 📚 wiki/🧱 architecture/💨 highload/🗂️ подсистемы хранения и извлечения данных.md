Многие базы данных используют *журналированные (log-structured)* или *постраничные (page-oriented)* подсистемы хранения.
### Журналирование
Довольно простая система, где есть файл (журнал), предназначенный только для добавления данных в конец.
**Уплотнение** - отбрасывание всех дублей из журнала и сохранение только последней версии данных для каждого ключа.

Тут нет удаления, строки журнала просто помечаются, как удаленные и не учитываются при следующем уплотнении.
### Индексы
Дополнительные структуры, которые ускоряют доступ к данным (поиск и фильтрацию), но при этом несут накладные расходы при записи, чтобы поддерживать индекс в актуальном состоянии. Также требуют дополнительное место на диске.
##### Хеш-индексы
Самые простые индексы, работа которых основана на тех же принципах, что и словарей во многих языках программирования.
Подходят для быстрого поиска по точному значению, но не поддерживают запросы по диапазону и `order by`. К тому же, неэффективны при коллизиях.
Полезен в нереляционных базах, например, для хранения кеша.
Нужно, чтобы все помещалось в оперативную память (при *NoSQL*).
##### SS и LSM
Sorted String Table - все значения в индексе отсортированы
- уплотнение решается почти тем же, что используется в `merge sort`
- в памяти можно хранить не все, а разреженные индекс, а искать по максимально схожим значениям
- при поступлении записи она добавляется в сбалансированную структуру данных (которая находится прямо в памяти) + пишется в лог
- на фоне работает уплотнение и слияние разбитых журналов (сегментов)
Log-Structured Merge-Tree - подсистемы хранения, основанные на принципе слияния и уплотнения отсортированных файлов.
На этом принципе работают движки Elasticsearch и Solr.
##### B-Tree
Хранят пары ключ-значение в отсортированном по ключу виде.
Журналированные индексы разбивают базу на сегменты переменного размера, порой до нескольких мегабайтов, тогда как эти - блоки (страницы) фиксированного размера (обычно 4 КБайт) и читают / записывают по одной странице за раз.

Все страницы имеют свой неизменный адрес, поэтому могут ссылаться друг на друга. К тому же, это происходит на диске, а не в памяти. Поиск всегда начинается с *корня* дерева.

Количество ссылок на дочерние страницы в одной странице называется коэффициентом ветвления.
При изменении просто меняются значения в странице, все ссылки остаются теми же. Если места в странице не хватает - страницы разбивается на две полупустые, а родительская меняется, чтобы поддержать изменения.

Дерево из 4 уровней, со страницами по 4 КБайт с коэффициентом ветвления 500 может хранить до 256 терабайт информации.

Для *отказоустойчивости* в индексе есть журнал упреждающей записи (**WAL** - Write Ahead Log).

Есть проблема при конкурентной записи, которая решается блокировками, тогда как в LSM такого не нужно, ведь там слияние происходит в фоновом режиме.

С B-Tree можно создавать *составные индексы*, тогда как такое невозможно с LSM.
### OLAP и OLTP
**OLTP** (online transaction processing) системы нацелены на работу с пользователями, и это означает огромное потенциальное количество запросов. Чтобы справить с такой нагрузкой, приложения затрагивает только несколько строк, которые удобно получить с помощью индексов. 
**OLAP** (online analytical processing) используется чаще всего аналитиками, а не конечными пользователями, поэтому менее широко известны. Тут индексы не играют большой роли, потому что поиска практически нет, зато идет агрегирование большого количества данных (до нескольких петабайтов). Для такого варианта обычно используются *колоночные* базы данных, потому что их внутреннее строение позволяет держать на диске и работать с данными проще, потому что можно работать со столбцами, а не с целыми строками в памяти.
**ETL** (extract - transform - load) - процесс помещения данных из OLTP в склад данных. Чаще всего либо периодическими дампами базы данных, или непрерывным потоком обновления.