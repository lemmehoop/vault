### Type alias
Самый простой указатель на тип для лучшей читаемости.
```python
Vector = list[float]
Vector: typing.TypeAlias = list[float]  # подсказка интерпретатору и либам про алиас

def func(vector: Vector): ...
```
### New Type
Добавляет реальную проверку, что тип сходится. Родительский тип прописать будет нельзя, потому что MyPy ругнется.
```python
class UserId(int): ...
# or
UserId = typing.NewType("UserId", int)
```
### TypeVar и ParamSpec
Простые представления типов.
```python
T = TypeVar("T")             # просто некий тип
S = TypeVar("S", bound=str)  # любой подтип строки
A = TypeVar("A", str, bytes) # строгое ограничение двумя типами
U = TypeVar("U", bound=str | bytes)  # любой подтип из представленных
V = TypeVar("V", bound=typing.SupportsAbs)  # любой тип с методом __abs__
```
### Generics
Позволяет сделать свой собственный класс параметризуемым.
```python
class CustomQueue(Generic[T]):
    def put(self, task: T) -> None:
        ...
    def get(self) -> T:
        ...

def communicate(queue: CustomQueue[str]) -> Optional[str]:
    ...
```
### Ковариантность
```python
class Animal: ...
class Dog(Animal): ...

# инвариантно - по умолчанию: List[Animal] != List[Dog], т.е. нельзя использовать другие подтипы Animal вместо Dog в Generic

# ковариантно: когда так делать можно, то есть List[Animal] <- List[Dog], т.е. можно использовать только для чтения типов
T_co = TypeVar("T_co", covariant=True)

# контрвариантно: когда List[Dog] <- List[Animal], можно использовать функционал для супертипа с подтипами во входных параметрах функций
T_contra = TypeVar("T_contra", contravariant=True)
```
### ParamSpec
```python
P = ParamSpec("P")
f: Callable[P, T]  # принимает P и возвращает T
```
### Protocol
Реализуют duck-typing: мы определяем тип класса не по отношению с другими классами, а по его интерфейсу.
```python
class Proto(typing.Protocol):
	def func() -> None: ...
```